---
id: conversion-tools-kompose-katenary
title: Converting with Kompose and Katenary
sidebar_label: Kompose & Katenary Conversion
---

# Converting with Kompose and Katenary

In this section, we'll explore two different tools for converting Docker Compose files to Helm charts: Kompose and Katenary. Each has its own strengths and limitations that we'll examine in detail.

## Converting with Kompose to Helm Chart

Kompose is a convenient tool that automates the translation of Docker Compose files into Kubernetes manifests and can also generate a basic Helm chart structure.

### Run Kompose Convert for Helm

Navigate to the directory containing your docker-compose.yaml file and execute the kompose convert command with the `-c` flag to generate a Helm chart.

```bash
cd compose2k8
kompose convert -c
```

This command reads your 'docker-compose.yaml' file and generates a Helm chart structure in a new directory (by default, named after your Docker Compose file or a generic name like 'docker-compose').

You might observe warnings during the conversion process, such as:

```
WARN /home/armada-user/examples/compose2k8/docker-compose.yaml: the attribute version is obsolete, it will be ignored, please remove it to avoid potential confusion
INFO Kubernetes file "app-service.yaml" created
INFO Kubernetes file "db-service.yaml" created
INFO Kubernetes file "app-deployment.yaml" created
INFO Kubernetes file "db-deployment.yaml" created
INFO Kubernetes file "postgres-data-persistentvolumeclaim.yaml" created
INFO Kubernetes file "db-cm1-configmap.yaml" created
INFO Helm chart "docker-compose" created in directory "docker-compose"
```

### Review Generated Helm Chart (Kompose)

After running `kompose convert -c`, inspect the newly created directory (e.g., docker-compose/). This directory will contain the basic structure of a Helm chart.

```bash
ls docker-compose/
# You should see files like:
# Chart.yaml
# values.yaml
# templates/
#   app-deployment.yaml
#   app-service.yaml
#   db-deployment.yaml
#   db-service.yaml
#   postgres-data-persistentvolumeclaim.yaml
#   db-cm1-configmap.yaml
```

:::warning Important Note on Kompose Artifacts
The Helm chart generated by Kompose is a good starting point but is often very basic. It directly translates the Kubernetes manifests it would normally generate into the templates/ directory and creates a simple Chart.yaml and values.yaml.
:::

### Limitations and Required Refinements

* **Limited Templating:** The generated YAML files in templates/ will have minimal Go templating. You'll need to manually add more `{{ .Values.someValue }}` references to make the chart truly configurable via values.yaml.  
* **Service Types:** Kompose might default to ClusterIP for services. You'll likely need to edit app-service.yaml in the templates/ directory to change type: ClusterIP to type: NodePort or LoadBalancer for external access, and potentially add nodePort if using NodePort.  
* **Resource Limits:** Kompose does not infer resource limits or requests. You should add resources.requests and resources.limits to your deployments in templates/ and expose them as configurable values in values.yaml.  
* **Secrets and ConfigMaps:** While Kompose might generate basic ConfigMaps or use secretKeyRef, you'll need to ensure sensitive data is handled securely and correctly, potentially using Helm's templating for dynamic values or external secret management.  
* **Ingress:** Kompose does not automatically generate Ingress resources. You'll need to manually create an ingress.yaml file in templates/ and configure it.  
* **Testing and Linting:** A generated chart should always be tested (helm lint, helm template) and manually verified before deployment.

### Verification Checklist for Kompose-generated Chart

* **Chart.yaml**: Verify name, version, and description.
* **values.yaml**: Add/refine configurable parameters (e.g., image tags, replica counts, service ports, resource limits).
* **templates/**:
  * **Image Names and Tags**: Ensure correct image names and tags are used, ideally templated from values.yaml.
  * **Ports**: Verify containerPort, port, and targetPort are correctly mapped.
  * **Environment Variables**: Check that all necessary environment variables are present and correctly sourced (from Secrets or ConfigMaps), and consider templating them.
  * **Volume Mounts and PVCs**: Confirm persistent storage is correctly configured and mounted to the appropriate paths.
  * **Service Types**: Adjust Service types (e.g., from ClusterIP to NodePort or LoadBalancer) based on your exposure requirements, and template the nodePort if used.
  * **Resource Limits**: Add or adjust CPU and memory requests/limits for production readiness, templated from values.yaml.

## Converting with Katenary to Helm Chart

Katenary is a tool specifically designed to convert Docker Compose files into configurable Helm charts, aiming to provide a more ready-to-use chart than Kompose.

### Prepare Docker Compose for Katenary (Optional but Recommended)

Katenary can leverage labels in your docker-compose.yaml to generate a more tailored Helm chart. While it can work without them, adding specific Katenary labels (e.g., for ingress, service types) can improve the conversion.

For example, to expose your app service via Ingress:

```yaml
# docker-compose.yaml (modified for Katenary labels)
services:
  app:
    image: userapp:1.1.2
    ports:
      - "5000:5000"
    environment:
      - POSTGRES_DB=mydatabase
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    labels:
      katenary.v3/ingress: |-
        hostname: myapp.local
        port: 5000
      katenary.v3/service-type: NodePort # Or LoadBalancer
  db:
    image: postgres:16
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=mydatabase
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:
```

:::tip
Adding Katenary-specific labels to your Docker Compose file can significantly improve the quality of the generated Helm chart, especially for networking configurations like Ingress and Service types.
:::

### Run Katenary Convert

Navigate to your compose2k8 directory and run Katenary.

```bash
cd compose2k8
katenary convert -c docker-compose.yaml -o ./charts/my-app-chart --appname my-app
```

Parameters explanation:
- `-c docker-compose.yaml`: Specifies the input Docker Compose file.
- `-o ./charts/my-app-chart`: Specifies the output directory for the Helm chart.
- `--appname my-app`: Sets the name of the application within the Helm chart.

Katenary will create a new directory (e.g., charts/my-app-chart) containing the generated Helm chart.

### Review Generated Helm Chart (Katenary)

Inspect the generated Helm chart. Katenary aims to produce a more templated and structured chart than Kompose.

```bash
ls charts/my-app-chart/
# You should see a more complete Helm chart structure, including:
# Chart.yaml
# values.yaml
# templates/
#   _helpers.tpl
#   app-deployment.yaml
#   app-service.yaml
#   db-deployment.yaml
#   db-service.yaml
#   ingress.yaml (if labels were used)
#   NOTES.txt
#   ... and potentially other resource types
```

### Benefits of Katenary

* **Better Templating:** Katenary often generates more robust templating in the templates/ files, making the chart more configurable via values.yaml out of the box.
* **Ingress Generation:** With appropriate labels, it can generate Ingress resources, which is a significant advantage.
* **Helper Templates:** It might include _helpers.tpl for reusable template snippets.
* **Structured Output:** The output is generally more aligned with standard Helm chart practices.

### Required Refinements for Katenary-generated Chart

While Katenary is more advanced, you'll still need to:

* **Review values.yaml:** Ensure all necessary parameters are exposed and have sensible defaults.
* **Fine-tune Resources:** Add or adjust resource requests and limits.
* **Secrets Management:** Verify how secrets are handled and integrate with your preferred secret management solution.
* **Advanced Features:** For very complex scenarios or specific Kubernetes features (e.g., Network Policies, PodDisruptionBudgets), manual additions will still be required.

## Common Improvements for Both Tools

Regardless of whether you use Kompose or Katenary, the following improvements are often necessary:

### 1. Enhanced Values Configuration

Edit values.yaml to expose more configuration options:

```yaml
# Improved values.yaml
app:
  image:
    repository: userapp
    tag: 1.1.2
    pullPolicy: IfNotPresent
  replicaCount: 1
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  service:
    type: NodePort
    port: 5000
    nodePort: 31380
  ingress:
    enabled: true
    className: nginx
    host: myapp.local
    path: /
    pathType: Prefix

db:
  image:
    repository: postgres
    tag: "16"
  replicaCount: 1
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi
  persistence:
    enabled: true
    size: 1Gi
  # Secrets should be managed separately in production
  auth:
    database: mydatabase
    username: myuser
    password: changeme
```

### 2. Update Templates to Use Values

Ensure your template files properly reference the values:

```yaml
# Example updated app-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "my-app.fullname" . }}-app
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
    component: app
spec:
  replicas: {{ .Values.app.replicaCount }}
  selector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
      component: app
  template:
    metadata:
      labels:
        {{- include "my-app.selectorLabels" . | nindent 8 }}
        component: app
    spec:
      containers:
        - name: app
          image: "{{ .Values.app.image.repository }}:{{ .Values.app.image.tag }}"
          imagePullPolicy: {{ .Values.app.image.pullPolicy }}
          ports:
            - containerPort: 5000
              name: http
          resources:
            {{- toYaml .Values.app.resources | nindent 12 }}
          env:
            - name: POSTGRES_DB
              value: {{ .Values.db.auth.database }}
            - name: POSTGRES_USER
              value: {{ .Values.db.auth.username }}
            - name: POSTGRES_PASSWORD
              value: {{ .Values.db.auth.password }}
```

### 3. Add a Proper Ingress Resource

If missing, add an ingress.yaml to the templates directory:

```yaml
{{- if .Values.app.ingress.enabled -}}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
  {{- with .Values.app.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  ingressClassName: {{ .Values.app.ingress.className }}
  rules:
    - host: {{ .Values.app.ingress.host | quote }}
      http:
        paths:
          - path: {{ .Values.app.ingress.path }}
            pathType: {{ .Values.app.ingress.pathType }}
            backend:
              service:
                name: {{ include "my-app.fullname" . }}-app
                port:
                  number: {{ .Values.app.service.port }}
{{- end }}
```

:::note
The examples above assume you have a _helpers.tpl file with helper templates like "my-app.fullname" and "my-app.labels". If these don't exist, you'll need to create them or modify the examples to use direct names.
:::

## Next Steps

In the next section, we'll explore an alternative approach using Score, a platform-agnostic workload specification. We'll also learn how to deploy our Helm charts to Minikube and verify their correctness through testing and validation.
