---
id: score-and-simplified-deployment
title: Score Conversion and Helm Deployment
sidebar_label: Score & Helm Deployment
---

# Score Conversion and Helm Deployment

In this section, we'll explore an alternative approach to conversion using Score, and learn how to deploy and verify Helm charts in a Kubernetes environment.

## Converting with Score to Helm Values (Alternative Approach)

Score is not a direct converter but a specification that defines your workload in a platform-agnostic way. You then use a Score implementation (like score-helm) to generate platform-specific configurations, such as Helm values files. This approach requires you to define your application in a score.yaml first.

### Create a Score Specification File (score.yaml)

Instead of converting docker-compose.yaml directly, you define your application's components, resources, and dependencies in a score.yaml file.

Create a file named score.yaml in your compose2k8 directory:

```yaml
# score.yaml
apiVersion: score.dev/v1b1
metadata:
  name: user-app
containers:
  app:
    image: userapp:1.1.2
    ports:
      http: 5000
    variables:
      POSTGRES_DB: ${resources.db.database}
      POSTGRES_USER: ${resources.db.user}
      POSTGRES_PASSWORD: ${resources.db.password}
resources:
  db:
    type: postgres
    class: standard
    properties:
      database: mydatabase
      user: myuser
      password: your_strong_password # Replace with a secure password or reference a secret
```

**Explanation:**

* `apiVersion` and `metadata`: Standard Score spec fields.
* `containers`: Defines your application containers.
  * `app`: Our Python Flask application.
  * `image`: The Docker image.
  * `ports`: Defines exposed ports.
  * `variables`: Maps environment variables, referencing resources defined below.
* `resources`: Defines external resources your application depends on.
  * `db`: A PostgreSQL database.
  * `type`: Specifies the type of resource (postgres).
  * `class`: A generic class (e.g., standard).
  * `properties`: Specific properties for the database, which will be used to generate connection details.

### Generate Helm Values Files with score-helm

Once you have your score.yaml, use the score-helm CLI to translate it into Helm values files.

```bash
cd compose2k8
score-helm run -f score.yaml -o user-app-values.yaml
```

This command will generate a user-app-values.yaml file.

Example user-app-values.yaml (simplified):

```yaml
# user-app-values.yaml
containers:
  app:
    image: userapp:1.1.2
    ports:
      http: 5000
    variables:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: your_strong_password
resources:
  db:
    type: postgres
    class: standard
    properties:
      database: mydatabase
      user: myuser
      password: your_strong_password
```

### Use with a Generic Helm Chart

The user-app-values.yaml generated by score-helm is *not* a complete Helm chart. It's a values.yaml file designed to be consumed by a generic workload Helm chart (e.g., score-spec/score-helm-charts). You would typically add this chart as a dependency or use it directly.

First, add the Score Helm charts repository:

```bash
helm repo add score-spec https://score-spec.github.io/score-helm-charts/
helm repo update
```

Then, you can install your application using the generic chart and your generated values:

```bash
helm install my-user-app score-spec/workload -f user-app-values.yaml
```

**Explanation:**
- `my-user-app`: The release name for your deployment.
- `score-spec/workload`: The generic workload chart from the Score repository.
- `-f user-app-values.yaml`: Uses your generated values file to configure the workload chart.

### Benefits of Score

* **Platform Agnostic:** Define your workload once and deploy to multiple platforms.
* **Clear Separation:** Separates application definition from infrastructure concerns.
* **Standardized Workload Definition:** Promotes consistency across projects.

### Limitations of Score

* **New Specification:** Requires learning the Score Specification.
* **Not a Direct Conversion:** You don't convert docker-compose.yaml directly; you define a new score.yaml.
* **Generic Chart Dependency:** Relies on a generic Helm chart for deployment, which might not offer the same level of granular control as a custom-built chart for very specific needs.

:::tip When to Use Score
Consider using Score when you want to deploy the same workload across different platforms (not just Kubernetes), or when you want to standardize workload definitions across your organization.
:::

## Deploying a Helm Chart to Minikube

Once you have a Helm chart (whether generated by Kompose, Katenary, or manually refined), you can deploy it to your Minikube cluster.

### Install the Helm Chart

Navigate to the directory containing your Helm chart (e.g., docker-compose/ for Kompose, charts/my-app-chart/ for Katenary).

```bash
# For Kompose-generated chart (assuming you are in compose2k8 directory)
helm install my-app ./docker-compose
```

```bash
# For Katenary-generated chart (assuming you are in compose2k8 directory)
helm install my-app ./charts/my-app-chart
```

You can also override values during installation:

```bash
helm install my-app ./docker-compose --set app.image.tag=2.0.0,db.replicas=1
```

This overrides the image tag for the 'app' and sets database replicas to 1.

### Verify Helm Deployment

Check the status of your Helm release:

```bash
helm list
```

Example output:

```
NAME     NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
my-app   default         1               2025-06-30 19:30:00.1234567 -0700 PDT   deployed        docker-compose-0.1.0    1.1.2
```

Verify that your Kubernetes services, deployments, and pods are running correctly:

```bash
kubectl get svc,deploy,pods
```

This lists all services, deployments, and pods in the current Kubernetes namespace, allowing you to see the status of your deployed application.

### Access the Application

Since Minikube runs in a VM (or Docker container), you need to identify the Minikube VM's IP address to access the application from your host machine.

```bash
minikube ip
```

Example output:

```
192.168.49.2
```

If your Helm chart exposes the app service as NodePort, find the NodePort:

```bash
kubectl get svc my-app-app-service # Replace 'my-app-app-service' with the actual service name in your chart
# Look for the PORT(S) column, it will show something like 5000:31380/TCP
```

Access the application using the Minikube IP and the NodePort (e.g., 31380):

```bash
curl 192.168.49.2:31380
```

If you configured Ingress in your Helm chart, you might need to add an entry to your /etc/hosts file (or equivalent on Windows) mapping the Ingress hostname to the Minikube IP, then access via the hostname (e.g., http://myapp.local).

:::tip
You can also use `minikube service my-app-app-service` to have Minikube automatically open the service in your default browser.
:::

## Helm Chart Verification and Local Testing

Before deploying your Helm chart to a production environment or sharing it, it's crucial to verify its correctness and test its behavior locally.

### Linting the Chart

Helm provides a built-in lint command to check your chart for possible issues, including syntax errors, adherence to best practices, and common mistakes.

```bash
helm lint ./my-app-chart
```

Example output (success):

```
==> Linting ./my-app-chart
[INFO] Chart.yaml: directory name (my-app-chart) and chart name (my-app-chart) must be the same
1 chart(s) linted, 0 chart(s) failed
```

### Dry-Running the Installation (Local Rendering)

The `helm template` command allows you to render the Kubernetes manifests that would be generated by your chart, without actually installing them on a cluster. This is invaluable for local testing and debugging templating issues.

```bash
helm template my-app ./my-app-chart --debug --dry-run
```

**Explanation:**
- `my-app`: A release name for the dry run (doesn't have to be unique).
- `./my-app-chart`: Path to your Helm chart.
- `--debug`: Shows additional debug information, including the values used.
- `--dry-run`: Renders the templates but does not install them.

This command will output the full Kubernetes YAML that would be applied. You can pipe this output to a file for review:

```bash
helm template my-app ./my-app-chart > rendered-manifests.yaml
```

You can also test specific value overrides:

```bash
helm template my-app ./my-app-chart --set app.replicaCount=3 --dry-run
```

This renders the chart with 'app.replicaCount' set to 3, allowing you to verify how your templates react to different input values.

### Running Helm Tests (if defined)

If your Helm chart includes test hooks (defined in templates/tests/), you can run these tests after installation to verify the deployed application's functionality.

First, install the chart (if not already installed):

```bash
helm install my-app ./my-app-chart
```

Then, run the tests:

```bash
helm test my-app
```

This executes any Kubernetes Jobs defined as test hooks within your Helm chart, allowing you to validate the deployed application.

### Creating Helm Test Hooks

You can add test hooks to your Helm chart to validate the deployment. Here's an example of a simple test that checks if the app service is accessible:

```yaml
# templates/tests/test-connection.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "my-app.fullname" . }}-test-connection"
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args: ['{{ include "my-app.fullname" . }}-app:{{ .Values.app.service.port }}']
  restartPolicy: Never
```

:::important
Test hooks are a crucial part of ensuring your Helm chart deploys correctly. They help catch issues early and provide confidence when making changes to your chart.
:::

## Next Steps

Now that you have successfully converted your Docker Compose application to a Helm chart, deployed it to Kubernetes, and verified its functionality, the next steps involve pushing your chart to a repository for sharing and exploring advanced considerations for production deployments.

In the next section, we'll cover how to package your Helm chart, push it to a remote repository, and address advanced topics like security best practices and resource management.
