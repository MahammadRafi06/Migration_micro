---
id: converting-with-kompose
title: Converting with Kompose
sidebar_label: Converting with Kompose
---

# Converting with Kompose

Kompose is a convenient tool that automates the translation of Docker Compose files into Kubernetes manifests. While powerful, it's essential to understand its capabilities and limitations.

## Run Kompose Convert

Navigate to the directory containing your `docker-compose.yaml` file and run:

```bash
cd compose2k8
kompose convert
```

This command reads your `docker-compose.yaml` and generates Kubernetes YAML files (Deployments, Services, PVCs, etc.) in the current directory.

You may observe warnings like:
```
WARN /home/armada-user/examples/compose2k8/docker-compose.yaml: the attribute \`version\` is obsolete...
```

Example output:
```
WARN docker-compose.yaml: the attribute `version` is obsolete
INFO Kubernetes file "app-service.yaml" created
INFO Kubernetes file "db-service.yaml" created
INFO Kubernetes file "app-deployment.yaml" created
INFO Kubernetes file "db-deployment.yaml" created
INFO Kubernetes file "postgres-data-persistentvolumeclaim.yaml" created
INFO Kubernetes file "db-cm1-configmap.yaml" created
```

:::warning Note on Kompose Artifacts
Artifacts generated by Kompose should always be **reviewed and edited manually** before deployment. Kompose provides a starting point but doesn't handle all advanced scenarios.
:::

### Limitations

- May not infer resource limits, advanced networking, or secret configurations properly.

### Checklist Before Deployment

-  Image names and tags
-  Ports (`containerPort`, `port`, `targetPort`)
-  Environment variables (ConfigMaps/Secrets)
-  Volume mounts and PVCs
-  Service types (`NodePort` if needed)
-  CPU/memory resource requests/limits

## Review Generated Manifests

After conversion, inspect the `.yaml` files created in your directory. Typical files include:

- `app-deployment.yaml`
- `app-service.yaml`
- `db-deployment.yaml`
- `db-service.yaml`
- `postgres-data-persistentvolumeclaim.yaml`

## Adjust Service Type for External Access

To expose your application via Minikube, modify `app-service.yaml`:

```yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    io.kompose.service: app
  name: app
spec:
  ports:
    - name: "5000"
      port: 5000
      targetPort: 5000
      nodePort: 31380  # Example NodePort in the range 30000â€“32767
  selector:
    io.kompose.service: app
  type: NodePort  # Changed from ClusterIP to NodePort
status:
  loadBalancer: {}
```

:::tip
**NodePort** services expose your application on a static port of the Minikube node's IP, allowing external access via `<NodeIP>:<NodePort>`.
:::

## Common Issues and Solutions

### Missing Environment Variables

If your Docker Compose file uses `.env` files or relies on host environment variables, Kompose may not capture these correctly. Consider creating ConfigMaps or Secrets manually for these values.

### Volume Persistence

Kompose creates PersistentVolumeClaim objects for volumes defined in Docker Compose, but you may need to:
- Specify the appropriate StorageClass
- Set proper access modes
- Configure capacity requirements

Example adjustment:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data-persistentvolumeclaim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi  # Adjust storage size as needed
  storageClassName: standard  # Specify the storage class if required
```

## Next Steps

Now that we have our Kubernetes manifests generated and reviewed, in the next section we'll deploy them to our Minikube cluster and learn how to manually create Kubernetes resources.